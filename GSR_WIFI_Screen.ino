/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/4f1e9c32-fb52-4feb-9f30-7338346aad0a 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int gSR;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_ST7735.h> // Hardware-specific library for ST7735
#include <Adafruit_ST7789.h> // Hardware-specific library for ST7789
#include <SPI.h>


const int GSR = A1;
int sensorValue = 0;
int gsr_average = 0;

// Define constants for the TFT display
  // For the breakout board, you can use any 2 or 3 pins.
  // These pins will also work for the 1.8" TFT shield.
  #define TFT_CS         5
  #define TFT_RST        4 // Or set to -1 and connect to Arduino RESET pin
  #define TFT_DC         3

// Create an instance of the Adafruit ST7789 display
Adafruit_ST7789 tft = Adafruit_ST7789(TFT_CS, TFT_DC, TFT_RST);

float p = 3.1415926;

// 每个水滴的结构体
struct Drop {
  int x;
  int y;
  int r;
  int v;
};

// 水滴的数量
const int NUM_DROPS = 10;

// 水滴的数组
Drop drops[NUM_DROPS];

void  waterdrops(unsigned long runtime){
  unsigned long endtime = millis() + runtime;
  tft.fillScreen(ST77XX_BLACK);
// 不停地模拟每个水滴的下落
  // while (millis() < endtime) {
    // 绘制每个水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r, ST77XX_BLUE);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y - drops[i].r/2, drops[i].x, drops[i].y - drops[i].r*2, drops[i].x + drops[i].r, drops[i].y - drops[i].r/2, ST77XX_BLUE);
    }

    // 延迟一段时间
    delay(10);

    // 抹去上一个位置的水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r, ST77XX_BLACK);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y - drops[i].r/2, drops[i].x, drops[i].y - drops[i].r*2, drops[i].x + drops[i].r, drops[i].y - drops[i].r/2, ST77XX_BLACK);
    }

    // 计算每个水滴的下一个位置
    for (int i = 0; i < NUM_DROPS; i++) {
      drops[i].y += drops[i].v;

      // 如果水滴到达了屏幕底部，将其重置到顶部
      if (drops[i].y > tft.height() + drops[i].r) {
        drops[i].y = -drops[i].r;
        drops[i].x = random(tft.width());
        drops[i].r = random(5, 15);
        drops[i].v = random(5, 15);
      }
    }
  // }
}

void flower(unsigned long runtime){
  unsigned long endtime = millis() + runtime;
  tft.fillScreen(ST77XX_BLACK);
// 不停地模拟每个水滴的下落
  // while (millis() < endtime) {
    // 绘制每个水滴
    for (int i = 0; i < NUM_DROPS; i++) {
    // 画花瓣
      tft.fillCircle(drops[i].x - drops[i].r, drops[i].y, drops[i].r, ST77XX_YELLOW);
      tft.fillCircle(drops[i].x + drops[i].r, drops[i].y, drops[i].r, ST77XX_YELLOW);
      tft.fillCircle(drops[i].x, drops[i].y - drops[i].r, drops[i].r, ST77XX_YELLOW);
      tft.fillCircle(drops[i].x, drops[i].y + drops[i].r, drops[i].r, ST77XX_YELLOW);

    // 画花心
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r/2, ST77XX_RED);
    }

    // 延迟一段时间
    delay(10);

    // 抹去上一个位置的水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      // 画花瓣
      tft.fillCircle(drops[i].x - drops[i].r, drops[i].y, drops[i].r, ST77XX_BLACK);
      tft.fillCircle(drops[i].x + drops[i].r, drops[i].y, drops[i].r, ST77XX_BLACK);
      tft.fillCircle(drops[i].x, drops[i].y - drops[i].r, drops[i].r, ST77XX_BLACK);
      tft.fillCircle(drops[i].x, drops[i].y + drops[i].r, drops[i].r, ST77XX_BLACK);

    // 画花心
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r/2, ST77XX_BLACK);
    }

    // 计算每个水滴的下一个位置
    for (int i = 0; i < NUM_DROPS; i++) {
      drops[i].y += drops[i].v;

      // 如果水滴到达了屏幕底部，将其重置到顶部
      if (drops[i].y > tft.height() + drops[i].r) {
        drops[i].y = -drops[i].r;
        drops[i].x = random(tft.width());
        drops[i].r = random(5, 15);
        drops[i].v = random(5, 15);
      }
    }
  // }
}

void ghost(unsigned long runtime){
  unsigned long endtime = millis() + runtime;
  tft.fillScreen(ST77XX_BLACK);
   // 不停地模拟每个水滴的下落
  // while (millis() < endtime) {
    // 绘制每个水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r, ST77XX_RED);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y + drops[i].r*3, drops[i].x, drops[i].y, drops[i].x + drops[i].r, drops[i].y + drops[i].r*3, ST77XX_RED);
      tft.fillCircle(drops[i].x - drops[i].r, drops[i].y + drops[i].r*1.5, drops[i].r/2, ST77XX_RED);
      tft.fillCircle(drops[i].x + drops[i].r, drops[i].y + drops[i].r*1.5, drops[i].r/2, ST77XX_RED);
      tft.fillCircle(drops[i].x - drops[i].r/2, drops[i].y + drops[i].r*3, drops[i].r/2, ST77XX_RED);
      tft.fillCircle(drops[i].x + drops[i].r/2, drops[i].y + drops[i].r*3, drops[i].r/2, ST77XX_RED);
      tft.fillCircle(drops[i].x - drops[i].r/2, drops[i].y, drops[i].r/2, ST77XX_WHITE);
      tft.fillCircle(drops[i].x + drops[i].r/2, drops[i].y, drops[i].r/2, ST77XX_WHITE);
    }

    // 延迟一段时间
    delay(10);

    // 抹去上一个位置的水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r, ST77XX_BLACK);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y + drops[i].r*3, drops[i].x, drops[i].y, drops[i].x + drops[i].r, drops[i].y + drops[i].r*3, ST77XX_BLACK);
      tft.fillCircle(drops[i].x - drops[i].r, drops[i].y + drops[i].r*1.5, drops[i].r/2, ST77XX_BLACK);
      tft.fillCircle(drops[i].x + drops[i].r, drops[i].y + drops[i].r*1.5, drops[i].r/2, ST77XX_BLACK);
      tft.fillCircle(drops[i].x - drops[i].r/2, drops[i].y+ drops[i].r*3, drops[i].r/2, ST77XX_BLACK);
      tft.fillCircle(drops[i].x + drops[i].r/2, drops[i].y+ drops[i].r*3, drops[i].r/2, ST77XX_BLACK);
      tft.fillCircle(drops[i].x - drops[i].r/2, drops[i].y, drops[i].r/2, ST77XX_BLACK);
      tft.fillCircle(drops[i].x + drops[i].r/2, drops[i].y, drops[i].r/2, ST77XX_BLACK);
    }

    // 计算每个水滴的下一个位置
    for (int i = 0; i < NUM_DROPS; i++) {
      drops[i].y += drops[i].v;

      // 如果水滴到达了屏幕底部，将其重置到顶部
      if (drops[i].y > tft.height() + drops[i].r) {
        drops[i].y = -drops[i].r;
        drops[i].x = random(tft.width());
        drops[i].r = random(5, 15);
        drops[i].v = random(5, 15);
      }
    }
}

void leaf(unsigned long runtime){
  unsigned long endtime = millis() + runtime;
  tft.fillScreen(ST77XX_BLACK);
// 不停地模拟每个水滴的下落
  // while (millis() < endtime) {
    // 绘制每个水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r, ST77XX_GREEN);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y - drops[i].r/2, drops[i].x, drops[i].y - drops[i].r*2, drops[i].x + drops[i].r, drops[i].y - drops[i].r/2, ST77XX_GREEN);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y + drops[i].r/2, drops[i].x, drops[i].y + drops[i].r*2, drops[i].x + drops[i].r, drops[i].y + drops[i].r/2, ST77XX_GREEN);
    }

    // 延迟一段时间
    delay(0);

    // 抹去上一个位置的水滴
    for (int i = 0; i < NUM_DROPS; i++) {
      tft.fillCircle(drops[i].x, drops[i].y, drops[i].r, ST77XX_BLACK);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y - drops[i].r/2, drops[i].x, drops[i].y - drops[i].r*2, drops[i].x + drops[i].r, drops[i].y - drops[i].r/2, ST77XX_BLACK);
      tft.fillTriangle(drops[i].x - drops[i].r, drops[i].y + drops[i].r/2, drops[i].x, drops[i].y + drops[i].r*2, drops[i].x + drops[i].r, drops[i].y + drops[i].r/2, ST77XX_BLACK);
    }

    // 计算每个水滴的下一个位置
    for (int i = 0; i < NUM_DROPS; i++) {
      drops[i].y += drops[i].v;

      // 如果水滴到达了屏幕底部，将其重置到顶部
      if (drops[i].y > tft.height() + drops[i].r) {
        drops[i].y = -drops[i].r;
        drops[i].x = random(tft.width());
        drops[i].r = random(5, 15);
        drops[i].v = random(5, 15);
      }
    }
  // }
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
  tft.init(240, 240);
  tft.setRotation(1);
  tft.fillScreen(ST77XX_BLACK);

    // 初始化每个水滴
  for (int i = 0; i < NUM_DROPS; i++) {
    drops[i].x = random(tft.width());
    drops[i].y = -random(tft.height());
    drops[i].r = random(5, 15);
    drops[i].v = random(5, 15);
  }

  waterdrops(10000);

  flower(10000);
  
  ghost(10000);
  
  leaf(10000);
  
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  
    long sum = 0;
    for (int i = 0; i < 10; i++)    //Average the 10 measurements to remove the glitch
    {
      sensorValue = analogRead(GSR);
      sum += sensorValue;
      delay(5);
    }
    gsr_average = sum / 10;
    Serial.println(gsr_average);
    gSR = int (gsr_average);
    
      if (1054 >= gsr_average && gsr_average >= 822) {
    waterdrops(10000);
  } else if (821 >= gsr_average && gsr_average >= 627) {
    flower(10000);
  } else if (626 >= gsr_average && gsr_average >= 596) {
    ghost(10000);
  }else if(595 >= gsr_average){
    leaf(10000);
  }
    
}
